# 计算机网络
- OSI七层模型和TCP/IP四层(五层)模型
- 运输层
	- TCP UDP
	- 端口
- 网络层
	- IP
- 应用层
	- HTTP
- TCP三次握手、四次挥手
- HTTP1和HTTP1.1、HTTP2.0区别
- TCP和UDP协议的区别于各自场景
- Cookie和Session
- OSI七层模型
- TCP/IP模型
- syn和SYN的区别

## 协议结构
### OSI七层模型
![OSI](https://images2015.cnblogs.com/blog/1099668/201702/1099668-20170212153338135-125492424.jpg)

- OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。
- OSI定义了网络互连的七层框架（**物理层、数据链路层、网络层、传输层、会话层、表示层、应用层**）。每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。

**每层的协议和作用**  

|-- |--|--|
||每层的协议|每一层的作用|
|物理层|RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）|通过媒介传输比特,确定机械及电气规范（比特Bit）|
|数据链路|PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）|将比特组装成帧和点到点的传递（帧Frame）|
|网络层|IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）|负责数据包从源到宿的传递和网际互连（包PackeT）|
|传输层|TCP、UDP、SPX|提供端到端的可靠报文传递和错误恢复（段Segment）|
|会话层|NFS、SQL、NETBIOS、RPC|建立、管理和终止会话（会话协议数据单元SPDU）|
|表示层|JPEG、MPEG、ASII|对数据进行翻译、加密和压缩（表示协议数据单元PPDU）|
|应用层|FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS| 允许访问OSI环境的手段（应用协议数据单元APDU）|


**常见协议：**

- ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
- TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
- HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
- DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
- NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
- DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

### TCP/IP四层模型 

![TCP/IP 五层](https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234826351-1957282396.png)

OSI中的物理层+数据链路层  对应  TCP/IP中的数据链路层（网络接口层），这样就是四层

### 五层协议
五层协议：物理层、数据链路层、网络层、运输层、 应用层。

### 对比
- OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型
- OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准

# 传输层
## 传输层的作用：为应用层提供了通信服务
在OSI七层参考模型中，传输层是面向通信的最高层，也是用户功能的最底层。
传输层的两大功能：**复用和分用**
- 复用：在发送端，多个进程公用一个传输层
- 分用：在数据接收时，传输层会根据端口号的不同，将不同数据传输到不同应用中。

**传输层和网络层的区别：**
​- 网络层为不同主机提供了通信服务，而传输层为不同主机的不同应用提供了通信服务
- ​网络层只对报文头部进行差错检测，而传输层则对整个报文进行差错检测

**重点：**
- 运输层的协议，进程间的通讯，端口
- UDP协议
- TCP协议和可靠传输（停止等待协议和ARQ协议）
- TCP的滑动窗口，流量控制，拥塞机制，连接管理

## 运输层协议
- 运输层向它上面的应用层提供通信服务
- 两台主机的通讯是两台主机中**应用进程相互通讯**，**运输层提供应用进程间的逻辑通讯**（网络层：主机通信（补充学习IP协议的内容））
- 运输层的重要功能：**复用**和**分用**，不同的应用进程用同一个运输层协议传输数据，并能在接收后交付正确的应用进程
- **面向连接的TCP**和**无连接的UDP**
- 运输层向高层用户屏蔽了网络核心的细节，多上层的表现根据协议而不同
	- TCP：一条全双工的可靠信道
	- UDP：不可靠信道

## 两个主要协议
- UDP：用户数据报协议
- TCP：传输控制协议

### UDP
- 在IP数据包服务的基础上，增加了复用，分用和差错检测
- UDP是**无连接**的
- UDP**尽最大努力交付**（不保证可靠交付）
- UDP是**面向报文**的
	- UDP一次交付一个完整的报文（应用层交给UDP后，UDP照样发送）
- UDP没有拥塞控制
	- 网络拥塞不会降低发包速率
- UDP支持一对一，一对多，多对一和多对多
- UDP首部开销小（UDP 8bytes，TCP 20bytes）

### TCP
- TCP是**面向连接**的运输层协议
	- 程序使用TCP协议之前必须先建立连接（三次握手），完成后需要释放连接（四次挥手）
- 每条TCP连接只能由两个端点（**点对点**）
- TCP提供**可靠交付**的服务
	- 数据无差错，不丢失，不重复，按序到达
- TCP提供**全双工通信**
	- TCP连接的两端都设有发送和接收缓存，允许通信双方应用进程在任何时候发送数据
- **面向字节流**
	- TCP不知道传输的字节流的含义，仅堪称无结构字节流
	- 不保证发送的数据块和收到的数据块对应，只保证发送的字节流和收到的字节流一样（应用程序到应用程序）

### TCP 和 UDP的区别
区别：

- 都是OSI模型中的传输层协议，TCP提供可靠的**通信传输**，而UDP则常被用于让**广播和细节控制交给应用的通信传输**。
- TCP面向连接，UDP面向非连接即发送数据前不需要建立链接
- TCP提供可靠的服务（数据传输），UDP无法保证
- TCP面向字节流，UDP面向报文
- TCP数据传输慢，UDP数据传输快

## 运输层的端口
**含义是：**（软件）端口是**应用层**各种协议进程与**运输实体**进行层间交互的一种**地址**。

为了不同操作系统的应用进程能够相互通信，使用统一的方法随TCP/IP体系的应用进程进行标志，需要目的主机提供的功能来识别终点。

在运输层使用**协议端口号**（简称端口）：所传送的报文交到目的主机合适的端口（网络层上，即IP协议），剩下的工作由TCP或UDP来完成

TCP/UDP的首部中都有**源端口**和**目的端口**这两个重要字段

- 服务器端使用的端口号：
	- **熟知端口号**（系统端口号）：LANA把这些端口号指派给了TCP/IP最重要的一些应用程序（例如HTTP:80）
	- 登记端口号：为了没有熟知端口号的应用程序使用的
- 客户端使用的端口号：
	- 短暂端口号，客户进程运行时才动态选择

### 常见端口及对应的服务
![常见端口](https://pic1.zhimg.com/v2-e584c505e895441d7b52c8f3c02c9770_b.png)

## 可靠传输
### 可靠传输的原理
TCP发送的报文段交给网络层（IP）传输--->IP是**尽最大努力服务**（不可靠传输）--->TCP采取措施使得传输层通信变可靠

在不可靠信道上实现可靠传输：

**停止等待协议**：把传输的数据单元称为**分组**，**停止等待**就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。  使用**确认和重传**机制在不可靠的传输网络上实现可靠的通信
> 运输层传送的协议数据单元叫报文段，网络层传送的协议数据单元叫IP数据报

**ARQ协议**（自动重传请求）：重传的请求是自动进行的，接收方不需要请求发送重传某个出错的分组。

**连续ARQ协议**：
发送方每收到一个确认就把发送窗口向前滑动一个分组的位置。接收方采取**累计确认**的方式，对最后一个到达的分组发出确认。
ARQ协议发送者每次只能发送一个分组，在应答到来之前必须等待，而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下，连续发送窗口中的分组。这样就减少了等待时间，提高了传输效率。
TCP滑动窗口实际上就是socket的接收缓冲区大小的字节数

## TCP的三次握手和四次挥手（连接管理机制）
### 三次握手
![三次握手](http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

**我要和你建立链接--->你真的要和我建立链接么--->我真的要和你建立链接--->成功：**

- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。


​SYN表示TCP三次握手中请求连接的标识符，SYN为1且ACK为0，代表客户端请求连接，SYN为1且ACK为1，表示服务器同意连接， ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。
ACK：用于应答；SYN：主要起到同步的作用

### 四次挥手
![四次挥手](http://static.zybuluo.com/Rico123/ardiuu1otopo9f1jd4df18iz/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

**我要和你断开链接--->好的，断吧--->我也要和你断开链接--->好的，断吧：**

- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

FIN为1表示报文段是一个连接释放请求，seq=u,u-1是A向B发送的最后一个字节的序号。

### 为什么TCP链接需要三次握手，两次不可以么，为什么？
为了防止 **已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。**若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了**。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。
#### 为什么要四次挥手？
（个人理解）因为TCP属于全双工通信，客户端和服务器可以互相发送数据。当客户端发送FIN之后，只是客户端不再发送数据，仍然需要服务器也发送FIN给客户端
#### 四次挥手时，client为什么TIME_WAIT状态还需要等待2msl后才能返回到closed状态？
四次挥手释放连接后，客户端进行TIME_WAIT等待的原因是，客户端发送给服务器的ACK可能会导致丢失，而2msl是一个报文的**最长生存周期**。如果2msl之内发送的ACK发生丢失，就重新发一次ACK给服务器来正确关闭这个tcp连接。超过2msl后，服务器会自动关闭。

​**两个原因：**
1. 保证客户端发送的最后一个ACK报文能够到达服务器。由于这个ACK报文段可能会丢失，因而使处在last-check状态的服务器接收不到已发送的ACK响应。服务器会重新发送一个FIN+ACK，使得客户端能够在2MSL时间内收到这个重传的FIN+ACK。这样，就能保证服务器进行正常的步骤进入CLOSE状态。
2. A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失，使得下一个新的连接中不会出现这种旧的连接请求的报文段。

# 网络层
- 数据报服务：网络层如何传递IP数据报
	- 网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务
	- 网络层不提供服务质量的承诺
- 虚电路服务：网络层如何选择合适的路由

网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)
## IP地址
IP地址是每台**主机**（或路由器）的每一个接口分配的**唯一**的**32位**标识符  
（区别MAC地址，MAC地址是硬件地址，IP地址是软件地址）

IP地址的分类：
32bits；   IP地址 = 网络号+主机号
![IP地址分类](https://pic3.zhimg.com/v2-7438cb1ba454ffe278f5c2310e69f3aa_b.png)

- **私有地址**：就是在互联网上不使用，而被用在局域网络中的地址
	- ABC类都有
- **保留地址**：特殊用途
	- A类：用作循环测试（测试本主机进程间通讯）
	- B类：如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP

### 地址解析协议ARP：
已知IP地址，解析物理地址
ARP高速缓存存放本局域网上从IP地址到硬件地址的映射表

过程：

- 每个主机都在自己的ARP缓冲区简历ARP列表，表示IP地址和MAC地址之间的关系
- 源主机发送数据时，检查ARP列表中是否有对应的IP地址的目的主机的MAC地址：有->发送
- 没有->向所有主机发送ARP数据包；每个主机收到数据包时，检查数据包中IP是否有自己的IP，不是则忽略；若是->取出IP地址和MAC地址写道ARP列表中，将自己的MAC地址写道响应包中告诉源主机
- 源主机收到响应包后，写入目的主机的IP和MAC到ARP列表中；若没收到ARP数据相应包则视为查询失败

**详细一点**
​网络层以上的协议使用IP地址来标识网络接口，但是以太数据帧传输时，以物理地址来标识网络接口，因此我们需要进行**IP地址与mac物理地址之间的转换**。对于IPV4来说，我们使用ARP地址解析协议来进行IP地址与物理地址之间的转换。**ARP协议提供了网络层地址到物理地址之间的转换**。原理是通过广播来实现。

​**ARP协议的工作原理如下：**
1. 每个主机都会在自己的ARP缓冲区中建立一个ARP列表，用于表示IP地址和MAC地址之间的对应关系。
2. **主机新加入网络（可能是mac地址发生变化，接口重启）时，会自动将该ARP报文把自己的IP地址与MAC地址的映射关系广播给其他主机**。
3. 网络上的主机免费接收到ARP报文后，会更新自己的ARP列表缓冲区，将新的映射关系更新到自己的ARP列表
4. 当某个主机需要发送报文时，首先检查ARP列表是否有对应的IP目的地址和目的主机的MAC地址，如果有，那就直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址等 。
5. 当本网络的所有主机接收到该ARP数据包时：
   1. 检查数据包中的目的IP地址是否是自己的IP地址，如果不是，就忽略该数据包
   2. 如果是，就首先从数据包中取出源主机的目的IP地址和MAC地址更新到自己的ARP列表中，如果已经存在，就覆盖
   3. 将自己的MAC地址写入到响应包中，告诉源主机是它想要的MAC地址
   4. 源主机收到响应后，将目的主机的IP地址和MAC地址写入到ARP列表中，并利用此数据发送数据。如果源主机一直没有收到ARP的响应数据包，则表示ARP查询失败。

## ip数据报

首部+数据

# 应用层
## HTTP协议
在 OSI 七层模型中，HTTP 协议位于最顶层的应用层中。通过浏览器访问网页就直接使用了 HTTP 协议。使用 HTTP 协议时，客户端首先与服务端的 80 端口建立一个 TCP 连接，然后在这个连接的基础上进行请求和应答，以及数据的交换。

由 HTTP 协议加载出来的网页，通常使用 HTML 语言来描述，因此 HTML 也可以理解为网页的一种数据格式。HTML 是一段纯文本，可以指定网页中的文字、图像、音频视频图片、链接，以及它们的颜色、位置等。无论计算机的底层结构如何，也无论网络底层使用了哪些协议，使用 HTML 展示出来的效果基本上是一致的。从这个角度来说 HTML 位于 OSI 七层模型的表现层。

### HTTP工作原理

​HTTP采用了**请求/响应**的模型，客户端向服务器发送一个请求报文，请求报文中包含请求的方法，URL、协议版本、请求头和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

​**以下是HTTP请求/响应的步骤：**
1. **客户端连接到web服务器**：
 一个HTTP客户端，通常是浏览器，与WEB服务器的HTTP端口（默认为80）建立一个TCP套接字连接
2. **发送HTTP请求**
 通过TCP套接字，客户端向web服务器发送一个文本的请求报文，一个请求报文由请求行、请求数据等组成
3. **服务器接收响应并返回HTTP响应**
web服务器解析请求，定位请求资源。服务器将资源复写到TCP套接字，由客户端来进行读取。一个响应由状态行、响应头部、空行和响应数据组成。
4. **释放TCP连接**
若Connection为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keep-alive,则保持该连接，在一定时间内可以继续接收请求。
5. **客户端浏览器解析HTML内容**
客户端浏览器首先解析状态行，查看表明是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集，客户端浏览器读取响应数据HTML，根据HTML的语法来进行格式化，并在浏览器窗口进行显示。

### 在浏览器中输入www.baidu.com后执行的全部过程
1. 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
2. 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
3. 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
4. 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

### DNS域名解析原理
当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。(???)

1、在浏览器中输入www.qq.com域名，操作系统会先**检查自己本地的hosts文件**是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 
2、如果hosts里没有这个域名的映射，则查找**本地DNS解析器缓存**，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 
3、如果hosts与本地DNS解析 器缓存都没有相应的网址映射关系，首先会**找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器**，此服务器收到查询时，如果要查询的 域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 
4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 
5、如果本地DNS服务器本地区域文 件与缓存解析都失效，则**根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS**，根DNS服务 器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负 责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址 (qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到 www.qq.com主机。 
6、如果用的是转发模式，此DNS服 务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地 DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 

### HTTP1.0、HTTP1.1和HTTP2.0
- HTTP1.0 : 是无连接、无状态的。浏览器的每次请求都需要与服务器建立一个新的连接，完成交互后立即断开。
- HTTP1.1：
	- 在HTTP1.0的基础上增加了**持久连接**(也称为长连接，在请求头中有keep_alive标志0)
	- 实现了请求的管道化
	- 增加了缓存处理(cache_control)
	- 实现了分块传输
	- 增加了Host字段，同时还实现了**断点续传**
- HTTP2.0:
	- 实现了二进制分帧
	- **多路复用**(连接共享)
	- 头部压缩
	- 服务器推送

主要区别在于 HTTP 1.0 中每次请求和应答都会使用一个新的 TCP 连接，而从 HTTP 1.1 开始，运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。
HTTP2.0通讯都在一个TCP连接上实现，这个连接可以承载任意数量额双向数据流。

## HTTP和HTTPS
HTTPS在HTTP的基础上通过SSL（TLS）安全套接字协议实现了数据传输的加密，客户端与服务器进行通讯需要提供一个CA（证书）非对称加密
**HTTP的默认端口是80，而HTTPS的默认端口是443**

**HTTPS的过程就是：**(重要)
在交互密钥阶段使用公开密钥加密方式，之后建立通信交换报文阶段则使用共享密钥加密方式。
1. 服务器会把自己的公开密钥登录至数字证书认证机构
2. 数字证书认证机构用自己的私有密钥向服务器的公开密码部署数字签名并颁发公钥证书
3. 客户端拿到服务器的公钥证书之后，使用数字签名认证的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的正确性。
4. 使用服务器的公开密钥对报文进行加密之后发送
5. 服务器用私有的密钥进行数据的解密

## HTTP中的请求（8）
- **GET**： 用于**请求访问**已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- **POST**：用于**传输信息**给服务器
- **PUT**： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- **DELETE**：删除文件，与PUT方法相反，删除对应URI位置的文件。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- OPTIONS：查询相应URI支持的HTTP方法。
- CONNECT：用于ssl隧道的基于代理的请求  
- TRACE：发送一个请求副本，以跟踪其处理进程 
### 对比GET和POST

|                  | GET                                                                                                           | POST                                                                  |
| ---------------- | ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| 功能           | GET用于请求数据                                                                                         | POST用于提交数据                                                |
| 查询字符串  |  GET 请求的 URL 中发送的                                                                               | POST 请求的 HTTP 消息主体中发送的                          |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符） | 无限制                                                             |
| 后退/刷新    | 无害                                                                                                        | 数据会被重新提交                                              |
| 缓存           | 能被缓存                                                                                                  | 不能缓存                                                          |
| 历史           | 参数保留在浏览器历史中                                                                             | 参数不会保存在浏览器历史中                               |
| 安全性        | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 |

## Sessoin和Cookie
补充
## 安全性
补充

# 题目


## HTTP和TCP关系
HTTP使用TCP作为它的支撑协议。HTTP客户首先发起一个与服务器的TCP连接。一旦建立连接，该浏览器和服务器进程就可以通过套接字接口访问TCP。TCP为HTTP提供了可靠数据服务。

## 面向连接和非面向连接的服务的特点是什么？
面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。

非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。

## 了解交换机、路由器、网关的概念，并知道各自的用途

### 交换机
在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。

交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。

交换机被广泛应用于二层网络交换，俗称“二层交换机”。

交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。

### 路由器

路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。

路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。

### 网关

网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。

在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。

在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。

网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。

对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。