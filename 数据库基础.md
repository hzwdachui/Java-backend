# 数据库
- Mysql数据库的索引
- （b、b+、hash索引、聚簇索引）
- 数据库事务ACID
- 事务读的几种状态
- 索引失效问题、
- 乐观锁(MVCC)和悲观锁-
- 数据库隔离级别       
- MyISAM和InnoDB区别          
- 聚簇索引     
- 数据库垂直、水平切分
- 数据库范式（并且能设计表，说出设计原理）
## 索引
索引是什么：索引是一种满足特定查找算法的**数据结构**，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。

**优点**
- 唯一性索引可以保证每行数据的唯一性
- 大大提高数据的检索速度
- 提高join，sort，分组的速度

**缺点**
- 维护索引耗费时间
- 索引本身占据大量空间

**哪里需要用索引：**
- 经常需要搜索的数据
- 主键列（保证唯一性）
- 经常需要join的列

**哪里不需要索引：**
- 不常搜索的列
- 不能显著加快搜索速度的列（数据值很少：例如只有男，女）
- 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 

### 索引类型
- **唯一索引**
	- 唯一索引是不允许其中任何两行具有相同索引值(value)的索引。
- **主键索引**
	- 将主键作为索引
- **聚簇索引**
	- 行的物理顺序与索引顺序相同，能提更快的访问速度

**主键就是聚簇索引？**
并不是，主键拍好序以后默认在主键上建立聚簇索引

### 索引实现方式
- B树索引：
	- 每个节点都存放索引和数据对象的指针
	- 性能：一次I/O把一个node放到page中。最多需要h次来检索一个数据
- B+树索引：
	- 非叶节点只有索引，叶节点存放数据对象的指针。且叶节点按关键码从小到大顺序用链表连接。
- hash索引：
	- 散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。
- 位图索引
	- 位图的基本思想就是对每一个条件都用0或者1来表示，如有5条记录，性别分别是男，女，男，男，女，那么如果使用位图索引就会建立两个位图，对应男的10110和对应女的01001,这样做有什么好处呢，就是如果同时对多个这种类型的字段进行and或or查询时，可以使用按位与和按位或来直接得到结果了。

**B树和B+树比较：** 
- B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。 
- 因为B树键位置不定，且在整个树结构中只出现一次，**虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加**。B+树相比来说是一种较好的折中。 
- B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。

**如何减少I/O？**
**局部性原理：** 磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中
事务管理
**磁盘预读：** 磁盘顺序读取的效率很高，预读的长度一般为页（page）的整倍数，主存和磁盘以页为单位交换数据。

### MySql索引
索引是一个排序的列表，在这个列表中，存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是通过索引表来找到改行的数据物理地址，提升访问速度。**Mysql主要提供的两种索引是：BTree索引和Hash索引。**
- **hash索引**：在mysql中，只有memory引擎支持hash索引，hash索引是memory表的默认引擎。由于索引自己仅仅存储很短的值，所以，索引非常紧凑。hash索引仅仅包含hashcode和记录指针，所以，mysql不能通过使用索引来避免读取记录。但是，访问内存中的记录非常迅速的，不会对性能造成太大影响。
​hash索引的缺点：**不能使用hash索引来进行排序**；hash索引不支持键的部分匹配，因为索引值是通过整个索引值来计算hash值的。另外，hash索引只支持等值比较，例如=， In。但是用 > 或<时，使用该索引是无效的。
- **聚簇索引**：**聚簇索引保证了关键字的值相近的元祖存储的物理位置也相同，并且一个表只能有一个聚簇索引**。在**聚簇索引的b树中，只有叶子节点包含了完整的元祖，而叶内节点仅仅只包含索引的主键的值**。
需要注意的是：InnoDB支持聚簇索引，而MyISAM不支持聚簇索引。如果在表中，**不指定主键的话，InnoDB会用一个具有唯一的且非空值的索引来代替**。如果不存在这样的索引，InnoDB就会定义一个隐藏的主键，然后对其建立聚簇索引。InnoDB按照聚簇索引的形式来存储数据，所以它的数据布局有着很大的不同。
​聚簇索引中的每个叶子节点包含primary key的值，事务ID以及回滚指针，分别用于事务和MVCC。
​为了提高聚簇索排序性能，最好的做法就是使用一个AUTO_Increment的列，这会保证记录按照顺序插入，而且能提高使用primary key进行连接和查询的性能。应该尽量避免随机的聚簇索引主键，比如字符串。
​在使用InnoDB的引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段来作为主键。
- **索引的优化**： 采用最左前缀匹配，一般**把排序分组频率最高的列放在最左边**。
- Mysql索引失效
	1. ​索引**无法存储null值**（索引是有序的，null值进入索引时，无法确定其应该放在哪里。）
	2. ​不适合键值较少的列 （重复数据太多，索引扫描小消耗也会很大） 
	3. ​模糊查询不能利用索引(like '%xx')
	4. ​使用条件中有or
	
## 数据库事务
### ACID  
​
- A(Atomic): 原子性： 一个事务中的所有操作，要么全部完成，要么全部不完成。 
- ​C(Consistency) : 一致性：在事务开始之前和事务开始之后，数据库的完整性没有被破坏，要么全部完成，要么全部不完成。
- ​I(Isolation) : 隔离性： 数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个并发执行时由于交叉执行而导致的数据不一致。
- ​D(Duration) : 持久性： 事务处理结束之后，对数据的修改是永久的，即时系统故障也不会丢失。

## 数据库并发控制
**事务**是并发控制的基本单位
并发控制：**隔离性**和**一致性**(C,I)

**并发带来的不一致性问题:**
- 修改丢失：A，B同时写，B覆盖了A的修改，A修改丢似乎
- 赃读：A写，B读，A撤销写，这时B读的是脏数据
- 不可重复读：A读取后，B更新，A无法重复读取该数据
- 幻读：A读取后，B增加或删除数据

**并发控制->隔离性->保证一致性**
锁，时间戳，乐观控制法，多版本并发控制(MVCC)

> Mysql乐观锁： MVCC原理： 不利用锁机制实现的隔离级别，主要实现了在保证数据一致性的前提下，实现了读写的并行。mvcc原理是非每一个数据的更新都有一个版本号。当写事务正在进行时，此时过来一个读事务，读事务会首先生成一个版本号，即该事务想读取哪一个版本的数据。
> Mysql悲观锁：先获取锁，再进行业务操作，即“悲观”地认为获取锁是非常有可能失败的，因此要先确保锁获取成功再进行业务操作。
### 事务隔离级别
1. ​读未提交
2. ​不可重复读
3. ​可重复读
4. ​串行化

其中，**mysql默认的事务隔离级别是可重复读**
### 封锁协议
X，S锁（略）

**意向锁：IS，IX，SIX**
如果对一个结点加意向锁，说明该结点的下层正在被加锁。**意向锁提高并发度**，减少加锁和减锁的开销。
- IS：在加S锁之前先加IS锁
- IX：在加X锁之前先加IS锁
- SiX：SIX = S + IX

**活锁和死锁**
- 活锁：
	- 某个T总是被别人插队，导致永远等待
	- 解决方案：先来先服务
- 死锁：
	- 循环等待
	- 解决方案：预防（一次封锁法，顺序封锁法）；撤销代价最小的事务，释放其所有锁，之后再恢复

**2PL 两段锁协议**
- 读写之前获得锁
- 释放某个锁之后就不再获得锁（就是最后大家一起释放锁）

### 可串行化调度
- 执行结果等于**串行调度**的叫**可串行化调度(serializable)**
- 利用**冲突**分析，如果**冲突可串行化**，那么可串行化调度

### 区别各种锁
#### Mysql表锁
mysql表锁有两种类型：**表共享读锁、表独占写锁**。
#### Mysql行级锁
InnoDB的行级锁主要分为两种状态：**共享锁**和**排它锁**。而在锁定过程中，为了让行级锁和表级锁共存，InnoDB同样使用了**意向锁**(表级锁定)，也就有了**意向共享锁和意向排它锁**。意向共享锁可以同时并存多个，但是意向排它锁只能存在一个。所以可以说，InnoDB的锁定模式实际上可以分为四种：共享锁、排它锁、意向共享锁和意向排它锁。
**InnoDB行锁是通过给索引上的索引项加锁来实现的**。所以，只有通过索引条件来检索数据，innoDB才使用行级锁，否则，INNODB将使用表级锁。
#### Mysql意向锁

​意向锁的作用是：
**当一个事务需要获取资源的锁定时，如果该资源已经被排它锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要排它锁定，则申请一个意向排它锁。**
**意向锁是表级行锁**。

#### Mysql悲观锁实现

​要使用悲观锁，首先必须**关闭**mysql数据库的自动提交属性，因为mysql默认使用autocommit模式，也就是说，执行一个更新操作后，msyql会立刻将结果进行提交。
​可以通过命令设置mysql为非autocommit模式：``set autocommit = 0；``
设置完autocommit后，我们就可以执行我们的正常业务了。

​可以**通过select语句**：``select ....   for update;``这样就实现了悲观锁。需要注意的是，**使用select for update会把数据给锁住，不过我们需要注意一些锁的级别，Mysql InnoDB默认Row-level Lock，所以只有明确指定主键，Mysql才会执行Row lock（行锁）；否则Mysql将会执行Table Lock（表锁），把整个表给锁住。**
​``select  ....... lock in share mode`` :表示将共享锁

## 数据库设计
设计几个表，谁做键之类的
### 数据库范式：
- 1NF：关系型数据库中最基本要求。**要求记录的属性是原子性**，不可分，就是属性不能分。一范式表示数据项不可再分了。
- 2NF：在1NF的基础上，不能够有部分依赖。**表中的每列都和主键有关**
​- 3NF：在第二范式的基础上再进一层，目标是确保每列都和主键列直接相关，而不是间接相关。即一个关系型满足第二范式，并且除了主键之外的其他列都不依赖于主键列，则满足第三范式。**3NF在2NF的基础上，消除了传递依赖**
- BCNF：BCNF所有依赖左部必须包含候选键。（在3NF的基础上，任何非主属性不能对主键子集依赖）
> 候选码，主码，主属性
> - 候选码：某一元素的值可以标识一个元祖而其子集不行
> - 多个候选码中的一个
> - 主/非主属性：不包含任何候选码的属性为非主属性

### 数据库水平、垂直拆分： 

​目前很多互联网系统都存在单表数据过大的问题，这就降低了查询速度，影响了客户体验。为了提高查询速度，我们可以通过优化sql语句、优化表结构和索引。不过对于那些百万级、千万级的数据库表，即使是优化过后，查询速度还是满足不了需求。这时候**我们可以通过分表降低单词查询数据量，从而提高查询速度**。一般分表的方式有两种：水平拆分和垂直拆分，二者各有利弊，适用于不同的情况。

1. 水平拆分：是指数据库表行的拆分。当表的行数超过200万行时，就会变慢，这时可以把一张表的数据拆分成多张表来存放。通常情况下，我们可以采用ID取模的方式把数据分散成若干张表。例如有400w的用户表users，为了提高查询效率我们可以把其分成4张表users1、users2、users3、users4。然后通过id取模的方式把数据分散到四张表内ID%4+1 = [1,2,3,4]。然后查询、更新、删除也是通过取模的方式来操作。

​水平拆分的优点：

- 表关联基本能够在数据库端全部完成
- 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题。
- 应用程序端整体架构改动相对较少。
- 事务处理相对简单。
- 只要切分规则就能够定义好，基本上较难遇到拓展性限制

水平拆分的缺点：

- 切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则
- 后期数据的维护难度有所增加，人为手工定位数据更困难
- 应用系统各个模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难

2. 垂直拆分：垂直拆分是数据库列的拆分，**把一张列比较多的表拆分为多个表**。表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。这时需要把大的字段拆分到另一张表，并且该表与原表是一对一的关系。**垂直拆分是指按照业务将表进行分类，分布到不同的数据库上面，这样就将数据的压力分担到不同的库中**。

​通常我们按照以下规则进行垂直拆分：

1. 把不常用的字段单独放在一张表
2. 把text、blob等大字段拆分出来放在一张附表中
3. 经常组合查询的列放在一张表中

垂直拆分的优点：

- 数据库的拆分后业务简单明了，拆分规则明确
- 应用程序模块清晰明确，整合容易
- 数据维护方便易行，容易定位
- 系统之间整合或拓展容易

垂直拆分的缺点：

- 部分表关联无法在数据库级别完成，需要在程序中完成
- 对于访问极其繁琐且数据量超大的表仍然存在性能瓶颈，不一定能满足需求
- 事务处理相对更为复杂
- 切分达到一定程度之后，拓展性会遇到限制
- 过度切分可能会带来系统过度复杂而难以维护


## 大数据处理
sort：external merge sort
count：先sort再count
hash：不会

## 算法优化设计
Nested Loop Joins
Block Nested Loop Join (BNLJ)
Index Nested Loop Join (INLJ)
Sort-Merge Join (SMJ)
Hash Join (HJ)

## 其他问题
**MyISAM与InnoDB的区别**

​MyISAM： 5.3之前的默认表类型。它是存储记录和文件的标准方法。它**不是事务安全的，而且不支持外键，它适合于读取大量的select**。MyISAM只支持表锁，而不支持行锁，因此在多update、select情况下，并发速度较低。myisam只能管理索引，在索引数据大于分配资源时，会由操作系统来cache

​InnoDB：5.3之后默认引擎。**支持事务的引擎，支持外键、行锁、表锁、事务**。如果有大量的update、insert，就适合于innoDB。但是InnoDB查询速度没有MyIsam快。InnoDB不管是数据还是索引，都是自己来管理。InnoDB给mysql提供了具有事务、回滚和崩溃修复能力的事务安全型表。InnoDB提供了行锁，提供了与oracle类型一致的不加锁读取。**InnoDB是mysql中第一个提供外键约束的表引擎**。InnoDB把表数据和索引放在表空间里，可能包含多个文件，这与其他引擎不一样。需要注意的是：innoDB行级锁的不同索引可能会导致死锁。

​关于主键：
- Myisam允许没有任何索引和主键的存在，同时myisam的索引都是保存的数据行指向的地址
- innodb如果没有主键，就会生成6个字节的主键，同时数据是索引的一部分

关于count：
- myisam保存有表的总行数，用select * from table;就会直接取出该值
- innodb没有保存表的总行数， 如果使用select count（*） from table；就会遍历整个表，消耗相当大，但是在加了where之后，myisam和innodb的处理方式都一样。

​总结：在写多读少的情况下，使用InnoDB插入性能更稳定。如果对读取速度要求更高，应用还是选择myisam比较好。

#### Mysql为什么使用B+树作为索引而不是红黑树作为索引？

​我们要考虑一个问题：**mysql如何衡量查询效率？ ------通过磁盘的IO次数。**

​B+树只有叶节点存放数据，其余节点用来存放索引，而B树是每个节点都会有data域。为了减少内存的占用，索引也会被存储在磁盘中。B+树除了叶子节点以外 ，其他节点并不存储数据，节点小，磁盘的IO次数就少。

​B+树所有的Data域都放在叶子节点中，一般来说会有一个优化，就是将所有的叶子节点用指针串起来，这样遍历叶子节点就能获得所有全部数据，这样就能实现区间访问。

​AVL树和红黑树基本上都是存储在内存中才会使用的数据结构。在**进行大规模存储的时候，红黑树往往由于树的深度过大而造成磁盘io读写过于频繁**。从而导致效率低下。磁盘查找存取的次数往往由树的高度决定。而红黑树的高度比较高。

#### 什么是存储过程？
​存储过程是一些预编译的sql语句。更加直白的讲，存储过程是一个记录集，它是由一些sql语句组成的代码块，这些sql语句代码像一个方法一样实现一个功能，然后再给这些代码块取一个名字，用到这个功能时候就可以直接调用了。

#### 什么是视图？

​	视图是一张虚拟的表，具有和物理表相同的功能。可以对视图进行CRUD，视图通常是由多张表的行和列组成。对视图的操作不会影响到原有表。相比于多表联合查询，视图使得我们获取数据更加容易。


