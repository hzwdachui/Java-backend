## 索引
索引是什么：索引是一种满足特定查找算法的**数据结构**，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。

**优点**
- 唯一性索引可以保证每行数据的唯一性
- 大大提高数据的检索速度
- 提高join，sort，分组的速度

**缺点**
- 维护索引耗费时间
- 索引本身占据大量空间

**哪里需要用索引：**
- 经常需要搜索的数据
- 主键列（保证唯一性）
- 经常需要join的列

**哪里不需要索引：**
- 不常搜索的列
- 不能显著加快搜索速度的列（数据值很少：例如只有男，女）
- 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 

### 索引类型
- **唯一索引**
	- 唯一索引是不允许其中任何两行具有相同索引值(value)的索引。
- **主键索引**
	- 将主键作为索引
- **聚簇索引**
	- 行的物理顺序与索引顺序相同，能提更快的访问速度

**主键就是聚簇索引？**
并不是，主键拍好序以后默认在主键上建立聚簇索引

### 索引实现方式
- B树索引：
	- 每个节点都存放索引和数据对象的指针
	- 性能：一次I/O把一个node放到page中。最多需要h次来检索一个数据
- B+树索引：
	- 非叶节点只有索引，叶节点存放数据对象的指针。且叶节点按关键码从小到大顺序用链表连接。
- hash索引：
	- 散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。
- 位图索引
	- 位图的基本思想就是对每一个条件都用0或者1来表示，如有5条记录，性别分别是男，女，男，男，女，那么如果使用位图索引就会建立两个位图，对应男的10110和对应女的01001,这样做有什么好处呢，就是如果同时对多个这种类型的字段进行and或or查询时，可以使用按位与和按位或来直接得到结果了。

**B树和B+树比较：** 
- B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。 
- 因为B树键位置不定，且在整个树结构中只出现一次，**虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加**。B+树相比来说是一种较好的折中。 
- B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。

**如何减少I/O？**
**局部性原理：** 磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中
事务管理
**磁盘预读：** 磁盘顺序读取的效率很高，预读的长度一般为页（page）的整倍数，主存和磁盘以页为单位交换数据。

## 数据库并发控制
**事务**是并发控制的基本单位
并发控制：**隔离性**和**一致性**(C,I)

**并发带来的不一致性问题:**
- 修改丢失：A，B同时写，B覆盖了A的修改，A修改丢似乎
- 赃读：A写，B读，A撤销写，这时B读的是脏数据
- 不可重复读：A读取后，B更新，A无法重复读取该数据
- 幻读：A读取后，B增加或删除数据

**并发控制->隔离性->保证一致性**
锁，时间戳，乐观控制法，多版本并发控制(MVCC)

### 封锁协议
X，S锁（略）

**意向锁：IS，IX，SIX**
如果对一个结点加意向锁，说明该结点的下层正在被加锁。**意向锁提高并发度**，减少加锁和减锁的开销。
- IS：在加S锁之前先加IS锁
- IX：在加X锁之前先加IS锁
- SiX：SIX = S + IX

**活锁和死锁**
- 活锁：
	- 某个T总是被别人插队，导致永远等待
	- 解决方案：先来先服务
- 死锁：
	- 循环等待
	- 解决方案：预防（一次封锁法，顺序封锁法）；撤销代价最小的事务，释放其所有锁，之后再恢复

**2PL 两段锁协议**
- 读写之前获得锁
- 释放某个锁之后就不再获得锁（就是最后大家一起释放锁）

### 可串行化调度
- 执行结果等于**串行调度**的叫**可串行化调度(serializable)**
- 利用**冲突**分析，如果**冲突可串行化**，那么可串行化调度

## 大数据处理
sort：external merge sort
count：先sort再count
hash：不会

## 优化设计
Nested Loop Joins
Block Nested Loop Join (BNLJ)
Index Nested Loop Join (INLJ)
Sort-Merge Join (SMJ)
Hash Join (HJ)
