## 1、数据库











​	answer：

​		

数据库事务的并发问题：

1. 脏读：事务A读取了B更新的数据，然后B回滚了该操作，那么A读到的数据就是脏数据。
2. 不可重复读：首先A读取了某一行的值，然后B更新了该行的值，A再读，发现不一致。
3. 幻读：A将数据库进行某个字段的全部更新操作，这时候B修改或新建了与A不一致的数据，然后A发现有数据不一致，以为没更新完毕。

注意：**不可重复读和幻读经常容易混淆，不可重复读侧重于修改，而幻读侧重于新增或删除。解决不可重复读的思路是锁住满足条件的行，而解决幻读就需要锁住整张表**。











**Mysql事务隔离级别**（answer）

















 



## 2、集合源码

cas、hashmap、concurrenthashMap、红黑树、AQS、hashtable、CopyOnWriteArrayList, CountdownLatch

BlockingQueue



## 3、数据结构

快排、堆排序、希尔排序、归并排序

​	直接插入排序： 基本操作是将一个记录插入到已经排序好的有序表中，从而得到一个新的、记录数增1的有序表。

​	折半插入排序：在直接插入的基础上，仅仅**减少了关键字之间所比较的次数**，通过对应索引元素i位置的值，与前i个已排序好的数组的第一个元素和最后一个元素比较直来进行相应的插入。

​	希尔排序： 又称为缩小增量排序。希尔排序中，若待排记录序列为正序时，其时间复杂度可为O(n)。

​				增量序列可以有各种取法，但需注意：应使增量序列中的值没有除1以外的公因子，并且最后一	    个增量值必须为1。	

​	

​	**快速排序**：快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则可对这两个部分记录继续进行排序，已达到整个序列都有序。

​	快速排序的改改进：通常采用三者取中的法则来选取枢纽记录，即取数组第一个元素值、中间元素值、和最后元素值的中间值来与第一个元素值对相互替换。通过采用三者取中对的规则可大大改善快速排序在最坏情况下的性能。快排的实现过程如下：

​	![1552183772709](C:\Users\朱立松\AppData\Local\Temp\1552183772709.png)

​	

​	**堆排序**：堆排序只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。



​	**归并排序**：归并的含义是将两个或两个以上的有序表组合成一个新的有序表。归并排序的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。**归并排序是采用分治法的典型应用**。



#### 	红黑树和平衡二叉树（AVL）的区别

​	AVL树是严格的平衡二叉树。平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作。只要不满足上面的条件，就要通过调整来保持平衡，而这样的调整是非常耗时的，因此，我们可以知道**AVL树适合用于插入和删除次数比较少。但是查找多的情况**。在**应用场景下，如果对插入和删除不频繁，只是对查找要求比较高，那么AVL树还是比较优于红黑树。**

​	红黑树：红黑树确保没有一条路径会比其他路径长出两倍。因此，红黑树是一种弱平衡二叉树（**由于是弱平衡，可以看到，在相同节点的情况下，AVL树的高度低于红黑树**），相对于要求严格的AVL树来说，所以**对于搜索、插入、删除操作较多的情况下，我们就用红黑树**。

​	

​	

B和B+树

二叉树和二叉平衡树

​	B和B+树 ：answer： B树能够存储数据，对其排序并允许时间复杂度为logn来进行查找、排序、插入和删除的数据结构。**B树为系统最优化大块数据的读和写**。B树算法减少定位记录所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。

​	对于M阶B树，每层每个块最多只能有M-1个元素，同时一个块最多只能有M个分支。

​	B+树是对B树的一种变形树，它与B树的差异在于：

- 有k个子节点的节点必然有k个关键码

- 非叶节点仅仅只有索引作用，跟记录相关的信息存放在叶节点中。

- 树的所有叶节点构成一个有序列表，可以按照关键码排序的次序遍历全部记录。

  

  **B树和B+树的区别是：B+树的非叶节点只包含导航信息，而不包含实际的值，所有的叶子节点和相连的节点使用链表来进行相连，便于区间查找和遍历**。

  但是B树也有其优点：B树的每个节点都包含了key和Value，因此经常访问的元素可能离根节点更近，因此访问速度也更快。


# 4、jvm

类加载机制、jvm运行时数据区、java内存模型、jvm分区



GC算法、minor GC 和full GC

jvm参数

CMS、G1（回收过程以及机制）

字节码

jvm调优



内存泄漏与内存溢出及其原因







## jvm常见命令

Xmx:最大堆容量

Xms:初始堆容量

Xmn:新生代容量

Xss:栈容量（栈帧大小）

-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机出现OOM时Dump出当前的内存转储快照以便于事后分析

-XX:MaxPermSize:最大方法区容量

-XX:PermSize:方法区大小

-XX:SurvivorRatio =8:Eden和Survivor的空间比例是8:1







## jvm运行时数据区域

​	



### 对象的创建过程

​

### 根据方法区中该类的信息确定该类所需的内存大小； 

一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。

从堆中划分一块对应大小的内存空间给新的对象； 
分配堆中内存有两种方式：

指针碰撞 
如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。
空闲列表 
如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。 
综上所述：JVM究竟采用哪种内存分配方法，取决于它使用了何种垃圾收集器。
为对象中的成员变量赋上初始值(默认初始化)；

设置对象头中的信息；

调用对象的构造函数进行初始化 



















### Sun JDK监控和故障处理工具

jps：所有HotSpot虚拟机进程

jstats: 用于收集HotSpot虚拟机各个方面的运行数据

jinfo:虚拟机配置信息

jmap:生成虚拟机的内存转储快照(heapdump)

jhat:分析heapdump文件，它会建立一个http服务器，让用户在浏览器上查看分析结果

jstack：显示虚拟机的线程快照







### Java语法糖

#### 	泛型与类型擦除

​	泛型的本质是参数化类型应用，也就是说所操作的数据类型被指定为一个参数，这种参数类型可以用在类、借口和方法中的创建中，分被称为泛型类、泛型接口、和泛型方法。

​	对于运行期的java来说，ArrayList<Integer>和ArrayList<String>是同一个类，泛型技术实际上是java的一个语法糖，java语言的泛型方法实现称为类型擦除。java代码被编译为class字节码文件后，泛型都会被擦除。

​	方法重载要求方法具备不同的特征签名，返回值并不在方法的签名之中，所以返回值不参与重载选择，但是在class文件中，只要描述符（包括返回类型）不是完全一致的两个方法就可以共存。



### Java内存模型

#### 硬件的效率与一致性

​	处理器要与内存交互，比如读取数据、存储计算结果等，这个IO操作是很难消除的。由于计算机的存储设备与处理器的运算速度存在几个量级的差距，所以不得不在运算器和存储设备之间加入一个高速缓存（Cache），使得所需要的数据存入到高速缓存中，运算结束后，再通过高速缓存写回到存储设备中。加入了高速缓冲的后果就是：带来了一个问题：缓存一致性。每个处理器都有自己的高速缓存，而它们最后都要写会同一个主存。



#### java内存模型

​	**java内存模型定义了所有的变量都存储在主存中，同时每个线程还有自己的工作内存，不同的内存无法访问对方的工作内存，只能通过主存的内容来进行通信。**

​	从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈的部分区域。主内存就直接对应于物理硬件的内存，而为了获得更好地运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存之间。

​	volatile可以说是java虚拟机提供的最轻量级的同步机制。volatile保证了两种机制：

1. 保证了内存可见性（对一个volatile变量的写操作先行发生于后面变量对这个变量的读操作）
2. 禁止指令重排序（保证了变量赋值的操作顺序与程序代码的执行顺序一致）



#### 	为什么volatile关键字能保证共享变量的内存可见性?

​	volatile修饰了一个成员变量后，这个变量的读写就会比普通变量多一些步骤。

- volatile变量写：当被volatile修饰了的变量进行读后，并不会写入到本地线程变量中，而是直接写到缓存中。
- volatile变量读：被volatile修饰了的变量被线程读时，线程不是从本地变量中读，而是在主存中去读。



#### 	指令重排序

​	重排序是指编译器、处理器在不改变程序执行结果的前提下，重新排列指令的执行顺序，来达到最佳的运行效率。重排序可分为编译器重排序和处理器重排序。





​	可见性：volatile、synchronized、final

#### 先行发生原则

判断数据是否存在竞争、线程是否安全的主要依据。如果操作A先行发生操作于B，就是指发生操作B之前，操作A的影响能被B察觉到。



java线程的几种状态：

1. 新建
2. 运行
3. 等待
4. 阻塞
5. 结束

### Synchronized关键字

​	synchronized经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference明确指定要加锁和解锁的对象。

​	执行monitorenter时，首先要获取对象的锁，如果这个对象还没被锁定，或者当前线程已经拥有了那个对象的锁，就把锁的计数器+1；相应的，执行monitorexit会把锁的计数器减1。当锁计数器为0时，锁就被释放了。





# 5、spring

ioc、aop、di。

IOC的实现、bean的注册过程(applicationContext -> beanDefinition -> listableBeanFactory -> 单例实例化)



#### Spring IOC

​	IOC(Inversion Of Control) 是指容器控制对象之间的关系，而不是传统实现中，有程序代码来直接控制。控制权由应用代码转到了外部容器，控制权的转移是所谓翻转。对于spring而言，就是由spring来控制对象的生命周期和对象之间的关系；IOC还有另外一个名字--(DI, Dependency Injectino ,依赖注入)。所谓依赖注入，即组件之间的依赖关系由容器在运行期间决定，即由容器动态地将某种依赖关系注入到组件中。

​	在spring的工作方式中，所有的类都会在spring容器中登记，告诉spring这是一个什么东西，然后spring会在系统运行到适当的时候，会把所需要的东西主动提供。所有用户自定义类的创建、初始化、销毁都由spring来控制，也就是说控制对象生存周期的不再是它所引用的对象，而是spring。对于某个具体的实现而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。

​	DI（依赖注入）的思想是通过反射机制来实现的，在实例化一个类的时候，它通过调用类中set方法将事先保存在hashMap中的类属性来注入到类中。总而言之，在传统的对象创建过程中，通常由调用者来创建被调用者的实例，而spring中创建被调用者的工作则由spirng来完成，然后注入调用者，即所谓的依赖注入or控制反转。注入方式有两种：依赖注入和设置注入；ioc的优点是：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。



1. Spring AOP


​	面向对象编程有些弊端，当需要为多个不具有继承关系的对象引入同一个公共行为时，例如日志、安全检测等，我们只有在每个对象中引入公共行为，这样程序中就产生了大量的重复代码，程序就不方便维护了，所以就有了对面向对象的补充，即面向切面编程(AOP),AOP所关注的方向是横向的，不同于OOP的纵向。

1. AOP面向切面编程，是对OOP的有益补充
2. AOP利用一种被称为横切的技术，剖解开封装的对象内部，并将那些影响了多个类之间的公共行为封装到一个可重用模块，并将其声明为“Aspect”。所谓切面，就是将那些与业务无关，却将业务模块所共同调用的逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。
3. AOP就是代表的一个横切的关系，讲对象比作为一个空心的圆柱体，其中封装了对象的属性和行为；而面向切面编程的方法，就是将这些圆柱体以切面的方式剖析开，选择性地提供业务逻辑。而剖开的切面，就是所谓的“方面”了。
4. 实现AOP的技术：主要分为两大类：一是采用动态代理的技术，利用截取消息的方式，对该消息进行修饰，用于取代原有对象的执行；二是采用静态织入的方式，引用特定的语法创建切面，从而使得编译器可以在编译期间织入相关切面的代码。
5. Spring实现AOP:JDK动态代理和CGLIB动态代理：代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理；其核心是两个类：InvocationHandler和Proxy。CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类拓展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（java字节码编辑类库）操作字节码来实现的，性能比JDK强。使用ASpect注入切面和@AspectJ注解驱动的切面实际上底层也是通过动态代理来实现的。



​	一个类被AOP织入Advice，就会产生一个结果类，它是融合了原类和增强逻辑的代理类。

​	在spring AOP中，一个AOP代理是一个JDK动态代理对象或CGLIB代理对象。

​	

​	在Spring AOP中，join point总是方法的执行点，即只有方法连接点。

​	advice是在join point 上执行的，而point cut规定了哪些join point可以执行哪些advice



#### 	织入(wearing)

​		将aspect和其他对象连接起来，并创建adviced object的过程

​		根据不同的实现技术，AOP有三种织入技术：

1. 编译器织入，这要求有特殊的java编辑器
2. 类加载器织入，这需要有特殊的特殊的类加载器
3. 动态代理技术，在运行期间为目标类添加增强(Advice)生成子类的方式。Spring采用动态代理织入，而AspectJ采用编译器织入和类加载期间织入。



​	JDK动态代理只能对实现了接口的类生代理，而不能针对类

​	CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成final。

​		

​	





#### Spring中的IOC加载过程

​	IOC容器的初始化是由refresh方法来启动的，这个方法标志着IOC容器的正式启动。

​	具体来说这个启动过程包括三个启动过程：

1. BeanDefinition的Resource定位
2. BeanDefinition的载入与定位
3. BeanDefinition在IOC容器中的注册



​	Resource定位：我们一般使用外部资源来描述Bean对象，所以IOC容器第一步就是需要定位Resource外部资源。Resource的定位就是BeanDefinition的资源定位，它是由ResourceLoader通过统一的Resource接口来完成的，这个Resurce对各种形式的BeanDefinition都是用了统一的接口。

​	

​	BeanDefinition的载入：

​	BeanDefinitionReader读取、解析Resource定位的资源，也就是将用户定义好的Bean表示成IOC容器的内部数据结构也就是BeanDefinition。在IOC容器内部维护着一个BeanDefinition Map的数据结构，通过这样的数据结构，IOC容器能够对Bean进行更好的管理。在配置文件中每一个<bean>都对应一个BeanDefinition对象。

​	

​	BeanDefinition的注册：

​	在IOC容器中注册这些BeanDefinition,这个过程是通过BeanDefinitionRegistry接口来实现的。在IOC容器内部其实是将第二部解析过程得到的BeanDefinition注册到HashMap中，IOC容器就是通过这个HashMap来维护这些BeanDefinition的。需要注意的是，这个过程并没有完成依赖注入，依赖注册在应用第一次调用getBean向容器所要bean时候。当然我们可以通过设置预处理，即对某个bean设置lazyinit属性，那么这个bean的依赖注入就会在容器初始化的时候完成。

##### ![1552812355813](C:\Users\朱立松\AppData\Local\Temp\1552812355813.png)



​	

#### Spring中bean的加载

1. 转换对应的beanName（去除factorybean的修饰符）
2. 尝试从缓存中加载单例（创建单例的时候会存在依赖注入的情况，而在创建的时候为了避免循环依赖，在spring中创建bean的原则是不等bean创建完成就会将创建bean的objectFactory提早曝光到缓存中）
3. bean的实例化
4. 原型模式的依赖检查
5. 检测parentBeanFactory
6. 寻找依赖
7. 针对不同的scope进行创建
8. 类型装换

**在默认情况下，spring通过反射机制利用bean的class属性来指定实现类来实现实例化bean**。



#### Spring中的生命周期

1. 实例化一个bean，也就是通常的一个new
2. 按照spring上下文对实例化的bean进行配置，也就是IOC注入
3. 如果这个bean实现了BeanNameAware接口，则调用这个setBeanName方法，此处传递的是spring配置文件中bean的ID
4. 如果这个bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(),传递的是spring工厂本身
5. 如果这个bean实现了ApplicationContextAware接口，会调用setApplicationContext方法，传入spring上下文
6. 如果这个bean关联了BeanPostProcessor接口，将会调用postProcessorBeforeInitialization方法，BeanPostProcessor经常被用作是bean内容的更改，并且由于这个是在bean初始化结束时调用after方法，也可用于内存或者缓存。



#### Spring中的BeanFactory和FactoryBean

​	BeanFactory是IOC最基本的容器，负责生产和管理bean，它为其他具体的IOC容器提供了最基本的规范，例如DefaultListableBeanFactory。它是创建bean的父接口。

​	

​	FactoryBean是一个接口,当在IOC容器中的Bean实现了FactoryBean之后，通过getBean(String beanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject方法返回的对象。想要获取FactoryBean的实现类，就要getBean(&beanName),在beanName之前加上&

​	FactoryBean和BeanFactory其实没有什么可比较性的，只是两者的名称特别接近，所以有时候会拿出来比较一番，BeanFactory提供了IOC最基本的形式，给具体的IOC容器的实现提供了规范，**FactoryBean可以说为容器中bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础之上加上了一层简单工厂模式和装饰模式，我们可以在getObject（）方法中灵活配置**。



#### @Autowired和@Resource的区别

​	@Autowired属于spring的注解，@Resource属于JSR-250的规范注解。@Resource的作用相当于		@Autowired，只不过@Autowired是按照byType来自动注入，而@Resource是默认按照byName来实现注入的。

@Autowired默认按照类型装配，默认情况下必须要求依赖对象必须存在。如果要运行null值，可以设置它的required属性为false，如果想要使用名称来装配就可以结合@Qualifier注解进行使用。







![1552792573835](C:\Users\朱立松\AppData\Local\Temp\1552792573835.png)



![1552805730365](C:\Users\朱立松\AppData\Local\Temp\1552805730365.png)

#### Spring MVC的处理流程

1. 用户向服务器发送请求，请求被spring前端控制Servlet DispatcherServlet捕获

2. DispatcherServlet对请求的URL进行解析，得到请求资源标识符（URI）。然后根据这个URI，调用HandleMapping获得该handler配置的所有相关的对象（包括handler对象以及handler对象对应的拦截器），最后以HandlerExecutionChain对象的格式返回。

3. DispatcherServlet根据获得的Handler,选择一个合适的HandlerAdapter。（如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler方法）。

4. 提取Request中的数据模型，填充Handler入参，开始执行Handler(Controller)。在填充Handler入参的过程中，根据对应的配置，Spring将进行一些额外的工作。

   ​	HttpMessageConveter:将请求消息（json，xml）等转换成一个对象，将对象转换为指定的相应信息

   ​	数据格式化：对请求消息进行数据格式化，比如将字符串转换成格式化数字或格式化日期等。

   ​	数据验证：验证数据的有效性（长度、格式等），验证结果存储到BidingResult或Error中。

5. Handler执行完成过后，向DispatcherServlet返回一个ModelAndView对象，选择一个合适的ViewResolver对象来返回给DispatcherServlet。

6. 将ViewResolver结合Model和View。来渲染视图。

7. 将渲染结果返回给前端

   

   #### 为什么SpringMVC只使用一个Servlet（DispatcherServlet）来处理所有请求？

   ​	

   #### 为什么SpringMVC要结合使用HandlerMapping以及HandlerAdapter来处理Handler？

   因为符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的代码可重用性高。比如HandlerAdapter可能会被用于处理多个Handler。

   

## 6、Redis

redis几种数据结构

应用场景

zset、LRU、FIFO、异步消息队列、计数器、分布式锁

为何单线程速度快

集群

持久化：AOF和RDB

#### 什么是Redis

​	Redis全称是 remote Dictionary Server。

​	Redis本质上是一个key-value类型的内存数据库，很像memCached,整个数据库统统加载在内存中进行操作，定期通过异步操作把数据库数据flush到硬盘中进行保存。

​	因为是纯内存操作，Redis性能非常出色，每秒可以处理10万次读写操作，是性能最快的Key-Value键值对数据库。

##### 	Redis与Memcached相比的优势

​	Memcached所有的值均是简单的字符串，redis作为其代替者，支持更加丰富的数据类型。

​	Redis的速度比Memcached快很多

​	redis可以持久化其数据



#### Redis支持哪几种数据类型

​	String (字符串) 。一个字符串类型的值最大能存储量为512M

​	List	（列表）

​	Set	（集合）

​	Sorted Set（zset，有序集合）

​	Hash （哈希表）



#### Redis的数据淘汰策略

​	LRU（最近最少使用）： 尝试回收最近最少使用的键，使得新添加的数据有空间存放。

​	TTL（Time To Live）: 优先回收存活时间比较短的键，使得新添加的数据有空间存放。

#### Redis集群方案应该怎么做？都有哪些方案？

1. codis 。目前用的最多的集群方案。
2. redis cluster。原理是其原理不是一致性hash，而是hash槽



#### Redis集群原理

​	![1552656542576](C:\Users\朱立松\AppData\Local\Temp\1552656542576.png)







​	Redis Cluster的原理：cluster是一个集群管理的插件，当我们存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接跳转到这个对应的节点进行存取操作。

##### 	Redis哈希槽： Redis集群中有16384个哈希槽，每个key通过CRC16检验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分槽。

​	Redis集群时，是有好多个redis一起工作的，那么，就需要这个集群不那么容易挂掉，所以理论上就应该**给集群中的每个节点备份至少一个的redis服务**。这个备份的redis称为节点(slave)。每一个节点都存有主节点以及从节点的信息。**Redis节点的复制策略是异步复制**。

​	它们之间通过互相的ping-pong判断是否这个节点可以连接上。如果有一半以上的节点去ping一个节点没有回应时，集群就认为这个节点宕机了，然后取连接它的备用节点。如果某个节点和所有从节点全部挂掉，我们集群就进入fail状态。如果一半以上的主节点宕机，我们集群同样也进入了发力状态。

##### 	Redis的投票机制

​	redis投票机制是集群中所有master参与，且当前master没有slave，集群进入fail状态，也可以理解成集群的slot映射不完整进入fail状态。

​	如果集群中超过半数的master挂掉，无论是否有slave，集群·就进入了fail状态。



##### 	Redis的主从复制模型

​	为了使部分节点失败或者大部分节点节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。Redis支持主从的模式。原则是：master会将数据同步到slave，而slave不会将数据同步到master。slave启动时会连接master来同步数据。

​	这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave来提供检索服务。这样可以有效减少单个机器并发访问控制数量。



#### Redis集群数据如何保证一致性？

​	是通过redis的主从复制来实现多个数据库之间的数据同步。master可以进行读和写，当发生写操作的时候，会自动将数据同步到slave数据库。



#### Mysql里有2000w数据，redis中只存20w数据，如何保证redis中的数据都是热点数据

​	answer：当redis中内存数据集上升到一定大小时候，就会进行数据淘汰策略。redis提供了6种数据淘汰策略：

​	voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

​	volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

​	volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

​	allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

​	allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

​	no-enviction（驱逐）：禁止驱逐数据



#### 	Redis的RDB和AOF

​	RDB(Redis DataBase)： RDB是Redis默认的持久化方案，在指定的时间间隔内，执行指定次数的写操作，会将内存中的数据写到磁盘中，即在磁盘中指定目录下生成一个dump.rdb文件。Redis重启会通过加载dump.rdb文件恢复数据。

​	RDB的优缺点

​	优点：

1. 适合大规模的数据恢复
2. 如果业务对数据完整性和一致性要求不高，RDB是很好的选择



​	缺点：

1. 数据的一致性和完整性不高，因为RDB可能在最后一次备份时宕机了。
2. 备份时占用内存，因为Redis在备份时会独立创建一个子进程，将数据写到一个临时文件，最后再将临时文件，最后再将临时文件替换之前的备份文件。



AOF（Append Only File）

​	Redis默认不开启。它的出现是为了弥补RDB的不足（数据不一致），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis重启会根据日志文件内容将写指令从前到后执行一次以完成数据的恢复工作。

​	正常情况下，将appendonly.aof文件拷贝到redis的安装目录中，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof进行修复。



### Redis的集合实现过程

​	有序集合的实现：通过跳表来实现排序的，用map来快速定位一个节点







#### Redis单进程单线程

​	redis采用队列技术量并发访问变为串行访问，消除了传统数据库串行控制的开销。



## 7、并发

synchronized的锁膨胀、CAS、volatile、ReentrantLock和Synchronized的区别

Synchronized底层(mutex标志位)

自旋锁

独占锁、共享锁

线程池、Condition

CopyOnWriteList

CountdownLatch、Semaphore

CyclicBarrier

Semaphore

Synchronized VS Lock



## 8、网络










#### 浏览器输入地址URL，按下回车后会经历的流程

1. 浏览器向DNS服务器请求解析该URL中的域名和所对应的IP地址
2. 解析出IP地址之后，根据该IP地址和默认80端口，和服务器进行TCP连接
3. 浏览器发出读取文件的HTTP请求，该请求报文作为TCP三次握手额第三个报文段的数据发送给服务器。
4. 服务器对浏览器请求做出相应，并把对应的HTML文本发送给浏览器。
5. 释放TCP连接
6. 浏览器将该HTML文件解析并显示







#### 传输层







![1552275904416](C:\Users\朱立松\AppData\Local\Temp\1552275904416.png)

TCP报文段的结构中有6个标志字段。分别为ACK、RST、SYN、FIN、PSH和URG。

ACK：确认字段中的值是有效的，即该报文段包含一个对已被成功接收报文段的确认。

SYN：连接建立

FIN：连接拆除



##### TCP和UDP的区别是什么？

​	tcp是面向连接的协议，在开始传输数据之前tcp客户端和服务器必须进行三次握手来保证连接的可用性，会话结束之后也要进行四次挥手，关闭连接。而udp是无连接的，无法保证数据是否能被收到。

​	tcp保证数据按序发送按序到达，**提供超时重传机制**来保证可靠性，通过滑动窗口来实现

流量控制；而udp不保证按序到达，甚至不保证到达，只是努力交付。同时UDP也一直是以固定速率进行传输

​	TCP协议所需资源多，TCP头部有20个字节，相反udp只有8个字节，udp协议传输量比tcp少

​	TCP有流量控制和拥塞控制；而udp没有，网络阻塞不会影响发送端的发送效率

​	tcp是一对一的连接；而udp可以实现多播和广播

​	tcp是字节流的服务；而udp是面向报文的服务



​	TCP包的大小是1460byte

​	UDP包的大小时1472byte



​	用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) - UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。  



​	用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。  

![img](http://images0.cnblogs.com/blog2015/621032/201508/092017231747399.jpg) 



##### 四次挥手

​	与建立连接的“三次握手”，断开一个TCP连接则需要“四次挥手”。

​	第一次挥手：主动关闭发送一个FIN，用来**关闭主动方到被动关闭方的数据传输**，也就是主动关闭方告诉被动关闭方，不会再给服务器发送数据了。

​	第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为(FIN+1),FIN为y。

​	第三次挥手：服务器发送一个FIN，用来**关闭服务器到客户端的数据连接**，此时会停止发送数据，同时会发一个FIN。

​	第四次挥手：客户端收到FIN，并发给服务器一个ACK给服务器，确认序号为收到的确认号+1

##### 三次握手时，发送方再次发送确认的必要性？

​	主要是为了防止已失效的连接请求报文段突然又传到了服务器，因而产生错误。假定出现一种异常情况，client发出的第一个请求报文段没有丢失，而是在某些网络节点中长时间滞留了，一直延迟到连接释放后的某个时间点才到达服务器，本来这是一个早已失效的报文段。服务器收到请求连接报文段后，就误认为client又发出了一次新的连接请求，于是就想client发出确认报文段，同意建立连接,但此时客户端此时却根本不会理会服务器的同意连接请求，导致服务器一直等待客户端的连接，造成资源浪费。



#### TCP滑动窗口协议（连续ARQ协议）

​	





### **流量控制**

​	流量控制的根本目的是防止分组丢失，它是构成TCP可靠性的一面。如何实现流量控制？通过滑动窗口来实现。滑动窗口保证了分组无差错、有序接收，也实现了流量控制。

​	TCP为它的应用程序提供了流量控制服务，以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。

​	TCP可能因为IP网络拥塞而被遏制，这种形式的发送方的控制被称为拥塞控制

TCP和UDP对应网络协议

​	TCP：HTTP、Telnet、POP3、FTP、SMTP

​	UDP: DNS、SNMP、TPTP



OSI七层模型

1. 物理层...............





1. 数据链路层：物理寻址，将原始比特转变为逻辑传输
2. 网络层：控制子网运行，同时将原始比特流转变为逻辑传输线路。通过路由选择算法，为报文或分组通过通信子网选择最合适的路径
3. 传输层：数据传输，并保证数据段可靠到达
4. 会话层：不同机器用户之间建立管理会话
5. 表示层：加密、解密、压缩/解压缩
6. 应用层：各种应用程序协议，比如HTTP、FTP、SMTP



##### 四次挥手释放连接时，等待2msl（最长报文段寿命）的意义？

![1552275387271](C:\Users\朱立松\AppData\Local\Temp\1552275387271.png)

​





​	

​	

#### TCP状态机

​	![1552813453572](C:\Users\朱立松\AppData\Local\Temp\1552813453572.png)















## 9、设计模式

代理模式(静态代理和动态代理)、依赖注入、抽象工厂和工厂

## 10、操作系统

进程和线程的区别

线程调度（内核线程和用户线程，内核级线程还是用户级线程）

​	answer：对于用户级线程，内核不知道线程的存在，就给了线程很大的自主权。用户进程只是调度进程，进程中的调度程序选择哪个线程来运行。对于内核线程，线程的调度就交给了系统来完成。

线程通信

进程和线程通讯

线程的状态

进程调度算法（FIFO、时间片、优先级、短作业）

虚拟内存（分页和分段）

什么时候发生死锁？如何解决（破坏死锁产生的四大条件）



#### 操作系统四大特性

​	并发、共享、虚拟化、异步

answer

​	**线程和进程的区别**

​		**资源分配与调度**

​		进程是资源分配调度的基本单位，表示一个运行中的程序；而线程是cpu资源调度的基本单位，也是程序执行的最小单位。

​		**时间与资源开销**

​		**进程有自己的独立地址空间**，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段。而**线程是共享进程中的数据的，使用相同的地址空间**，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的资源消耗也远比进程小。

​		**通信**

​		线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式来进行。

​		**健壮性**

​		多进程程序更加健壮，多线程程序只要有一个死掉了，整个进程也就死掉了。而一个进程死掉并不会对另一个进程造成影响。

​	

#### 进程通信的几种方式

- 共享存储。几个进程共享某一内存区域，通过该内存区域的数据资源来进行交互。需要注意的是：该内存区域需要通过特殊的系统调用才能完成。
- 消息传递。1：直接通信：发送进程直接把消息发给接收进程。2：间接通信方式：发送进程把消息发送到某个中间体中，然后接收的进程来读取该中间体的内容。
- 管道通信：管道：连接一个读进程和一个写进程来实现它们之间通信的一个共享文件，又称为pipe文件。向管道提供输入的发送进程，以字符流形式将大量的数据送到写进程。管道必须提供以下的协调能力：互斥、同步和确定对方的存在。



#### 	进程的同步方案

​	经典同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题

​	同步的解决方案是：管程、信号量



#### 	线程调度

1. 时间片调度

2. 抢占式调度

   

   

   #### 死锁产生的四个必要条件	

   1. 互斥条件：进程对所分配的资源进行排他性的调用(排他性)
   2. 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源
   3. 不可剥夺条件： 进程对于已经申请到的资源在使用完成之前不可以被剥夺
   4. 环路等待条件：发生死锁的时候存在一个进程-资源，环形等待链



#### 	死锁的处理

- 预防死锁：破坏死锁的4个必要条件的一个或者多个
- 避免死锁：在资源的动态分配中，防止系统进入不安全状态。（银行家算法）
- 检测死锁： 允许系统运行过程中产生死锁，死锁发生后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度比较大。
- 解除死锁：与死锁检测配合，将系统从死锁中解脱出来，对检测到的死锁相关的进程和资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的线程，使其转变为就绪态。



#### 进程调度算法

​	先来先服务、短作业优先、高响应比算法、时间片轮转算法、多级反馈队列调度算法



![1552310115620](C:\Users\朱立松\AppData\Local\Temp\1552310115620.png)





#### 	分段和分页的比较

​	把主存空间划分为大小相等的且固定的块，块相对较小，作为贮存的基本单位。每个进程也以块为单位进行划分，程序在执行时，以块为单位逐个申请主存中的块空间。因为程序数据存储在不同的页面上，页面又离散分布在内存中，因此需要一个页面来记录逻辑地址和实际存储地址的映射关系，从而实现页号到物理块号的转变。

​	分页是为了提高系统内存利用率，而分段则是为了满足程序员在编写代码的时候的一些逻辑需求。

![1552310869705](C:\Users\朱立松\AppData\Local\Temp\1552310869705.png)



​	页是信息的物理单位，是出于系统内存利用率提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。

​	分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

​	程序的地址空间划分为多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

- 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段
- 地址空间的维度：页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使得程序和数据可以被划分为逻辑上的地址空间，并且有助于共享和保护。



#### 	虚拟内存

​	基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动执行。在程序的信息不在内存时，有操作系统将所需要的部分调入内存，然后继续执行程序。操作系统将内存中暂时不需要用的内容换出到外存中，从而腾出更多空间存放将要存入内存的信息。

​	**虚拟内存技术的核心就是利用了局部性原理，把所要运行的进程中的数据不全部加载到内存中执行，而是加载一部分，当CPU在请求页表时，发现页表中的页表条目中的有效位为0但是被虚拟存储系统分配了的虚拟页时，就会把这个虚拟页从磁盘中调度到内存中（往往磁盘中的数据不常用，而在内存中的物理页的数据是频繁使用的数据），这样一来，我们就实现了多个进程同时加载到内存中并且还占用不是很多的内存的效果了** 。

​	虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好地管理内存，操作系统将内存抽象为地址空间，每个程序都有自己的地址空间，这个地址空间被分为多个块，每一个块被称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页面时，由硬件执行必要的映射，将缺失的部分装入内存并重新执行失败的指令。

​	虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序称为可能。



​	





​		

## 11、分布式

2pc、3pc

cap、base

paxos、zab

分布式缓存、session、消息队列

负载均衡、zookeeper



## 12、算法

​	分治法： 将一个问题规模为n的问题，若该问题可以很容易地解决， 则直接解决。否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题格式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种的算法策略成为分治法。

​	动态规划（DP，Dynamic Programming）：动态规划的实质是分支思想和解决冗余，因此动态规划实际上是将问题实例分解为更小的、更相似的问题，并存储子问题的解从而避免计算重复的子问题，用来解决最优化的算法策略。动态规划都是将问题实例分解为更小的、相似的子问题，并通过求解子问题来产生一个全局最优解。其中，**对于问题中的子问题如果都已选择，则采用贪心法来选取当前的最优解**。

​	回溯法：



​	贪心法：



## 13、IO

#### 	java中有哪几种类型的流？

​	字符流和字节流。字节流继承自InputStream和OutputStream。字符流继承自InputStreamReader和OutputStreamWriter。**java io使用了两种设计模式：适配器模式和装饰器模式**。

​	装饰器模式：由inputStream、outputStream和Reader和Writer的子类分别负责byte和插入流的根部。

一些流处理器可以对另一个流处理器起到装饰作用，形成新的、具有改善的功能的流处理器。

​	适配器模式：由inputstream、outputstream、reader和Writer代表的等级结构内部，有一些流处理器是对其他类型的流处理器的适配。这就是适配器的应用。

​	底层设备永远只接受字节数据。字符流是字节流的包装，字符流则是永远接受字符串，内部将字符串转成字节，再写入底层设备。

#### 	NIO

​	NIO和BIO的区别：

​	BIO：面向流、阻塞式io

​	NIO：面向缓冲、非阻塞式IO、选择器。

​	BIO和NIO的最大区别在于：IO是面向流的，NIO是面向缓冲区的。面向流意味着每次从流中读取一个或者多个字节，直至读取所有字节，它没有被缓存到任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java BIO的各种流是阻塞式的。这意味着，当一个线程调用read或者write时，该线程就会被阻塞，直到有一些数据被读取，或者数据完全写入，如果目前没有数据可以被获取，则阻塞。

​	**Java NIO**是一种非阻塞模式的，一个线程从某个通道发送请求读取数据，但是它目前仅仅能够得到目前可用的数据，如果目前没有数据可以使用，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可用之前，该线程可以继续做其他的事情。一个线程请求写入一些数据到某个通道，但不需要等待它完全写入，这个线程可以去做别的事情。线程通常将非阻塞式io的空闲时间用在其他通道上执行io操作，所以**一个单独的线程现在可以管理多个输入和输出通道**。

​	NIO可以只是用几个线程管理多个通道，但付出的代价是解析数据可能会比一个阻塞式流中读取数据更复杂。

​	

​	**JDK Selector是java的非阻塞式io实现的关键。它使用了事件通知API来确定一组非阻塞式套接字中有哪些已经就绪能够进行io相关的操作。因为在任何的时间检查任意的读操作或写操作的完成状态，因此一个单一的线程能够处理多个并发的连接。**	

​		

​	Netty通过触发事件将Selector从应用程序中抽象出来，消除了本来需要手动编写的分发代码。在内部，将会为每个channel分配一个EventLoop，EventLoop对应于NIO中的一个线程，用以处理IO事件。一个EventLoop对应多个Channel，Channel对应于Socket



## 14、Linux

​	top命令： 相当于windows的资源管理器，能够同台实时的显示系统种进程的资源占用情况。

## 15、其他

== 和equals

Runnable和Thread

刷leetcode

wait、notify、notifyAll

Restful

docker和虚拟机区别

字节流和字符流

Bio和Nio、IO多路复用、Netty和Nio

Servlet如何处理多个请求(web服务器启动，servlet就被加载并被实例化，servlet是单例的，初始化的过程就是读取配置文件)，request和response实例化过程，生成调用链，然后请求调用connector和container，http请求包装、然后经过调用链（用到了责任链模式），请求servlet，执行service方法。

linux打开一个read函数运行过程：

​	从用户缓冲区到内存缓冲区，read操作，阻塞等待系统调用完成，io操作需要进行磁盘寻道，内存读取数据，写入缓冲区，调用返回。



#### Servlet的生命周期

1. 加载和实例化
2. 初始化
3. 请求处理‘
4. 服务终止




​	servlet容器是采用单实例多线程的方式来处理多个请求的。当web服务器启动时，servlet就被加载并实例化（只存在一个servlet实例）

​	当请求到达时，servlet容器通过调度线程（Dispatcher Thread）调度它管理下线程池中等待执行的线程(Worker Thread)给请求者。

​	线程执行servlet的service方法。

​	请求结束，放回线程池，等待被调用



#### CyclicBarrier和CountDownLatch的区别

​	CountDownLatch是一个同步的辅助类，允许一个或者多个线程，等待其他一组线程完成操作，再进行操作

​	CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行



