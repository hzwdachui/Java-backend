# OO
- 抽象
- 封装
- 继承
- 多态
## 抽象
一类事物的属性和方法抽象成一个类，使其属性私有化，方法公开化。代码的复用性提高。

- 易扩展
- 易维护

## 封装
封装就是对属性和方法的载体，只能通过其提供的接口来访问。

### 封装的做法:
1. 私有属性(private修饰符修饰属性)。
2. 提供public的读(getXX)写(setXX)方法。
3. 在构造中调用方法.所有的非常量属性基本都需要封装.

### 封装的好处：
1. 隐藏类的实现细节
2. 对所有用户提供统一的接口
3. 增强执行效果.
4. 易于维护和扩展

## 继承
### 继承
继承是一种关系,逻辑上满足子类is a 父类的关系才使用继承.

- 子类继承父类的属性和**非私有方法**.不能继承父类的构造,继承关键字**extends**,类**单**继承,接口多继承.  
（Java不支持多重继承，通过接口或者内部类的方式实现）
- 在构造子类对象时,依次调用父类的构造(子类默认调用父类的无参构造.可以使用super(参数列表)来调用指定的父类的含参构造)到Object为止.再调用子类自身的.
- 子类调用父类的构造时,父类的构造只能调用一个且必须写在子类构造的第一句.

## 多态
### 什么是多态
**接口的多种不同的实现方式即为多态**  

**允许将子类类型的指针赋值给父类类型的指针**（爸爸做出儿子的行为）

最常见的：  多态的体现的例子（A只能用List和ArrayLis都有的方法）  
``List A = new ArrayList() ;``     
``List B = new linkedlist() ;``  

建立一个父类对象的引用，java中当子类拥有和父类同样的函数，当通过这个父类对象的引用调用这个函数的时候，调用到的是子类中的函数。

1. 只能使用父类中方定义的属性和方法
2. 子类中定义的不能直接使用
3. 子类复写了父类的方法,此时调用情况根据方法是否static而不同 [**static(调用父类),非static(调用子类)**].
4. **如果想使用子类中定义的方法,可以强制类型转换**(判断是否可以转换,用instanceof运算符来判断对象的类型)

### 重载和重写
- 重载是同一个类不同的方法，参数不同
- 重写是父子类中，方法名，参数完全相同的方法
#### 重载 overloading
方法的重载要求方法名必须相同,参数必须不同(参数个数不同、类型不同、顺序不同<(int,String)和(String,int)是不一样的>).返回值类型可以相同可以不相同.
#### 重写 override
- 方法名、参数列表和返回类型必须相同(5.0以后允许返回子类类型).
- 访问权限可以改但是不允许更小.(即子类的访问权限要么大于父类的要么相同,不允许小于父类的访问权限)
- 抛出的异常不能更大.

# 其他题目


## 接口与抽象类的区别？ 
（1）抽象类使用abstract修饰 ，接口使用interface修饰。 
（2）抽象类可以有普通方法，有抽象方法的一定要有抽象类，接口不可有有普通方法只能有抽象类。 
（3）抽象类可有有普通属性，接口只能是常量。 
（4）抽象类和接口不能实例化，就是不能new，就是不能创建对象，因为不是具体的。 
（5）抽象类有构造方法，接口没有构造方法。 
（6）抽象类只支持单继承支持多实现，接口支持多继承。 

## 类的组成和执行顺序? 
（1）类的组成：属性 方法 静态块 非静态块。 
（2）执行顺序：父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法。 

## 构造方法可否能被重写? 
不能被重写，只有继承关系才能重写，构造方法不能被重写，但是能被重载

## String与StringBuffer,StringBuilder的区别? 
（1）String是不可变的字符串常量对象，就是字符串序列底层实现是char数组，因为是数组所以定长（一但定义长度就固定不变）。 
（2）StringBuffer线程安全的可变字符串，底层实现是一个“可变长的数组”，数据安全效率低。 
（3）StringBuilder用作替换StringBuffer，JDK1.5新增类，线程不安全的可变字符串，效率高。 

##（= =）与equals（）的区别? 
（1）==：引用类型比较的是地址，基本类型比较的是值 
（2）equals:底层比较的是地址（ 
public boolean equals(Object obj) { 
return (this == obj); 
}），重写equals方法比较的是内容。 

## 什么是拆箱和装箱? 
JDK1.5提供了自动装箱和自动拆箱功能 
（1）装箱就是自动将基本数据类型转换为包装器类型，就是可以把一个基本类型变量直接赋值给对应得包装类型变量，或者赋值给Object变量（Object是所有类的父类，子类对象可以直接赋值给父类变量）； 
（2）拆箱就是自动将包装器类型转换为基本数据类型，允许直接把包装类对象直接赋值给一个对应的基本类型变量。 

## final类有什么特点？ 
（1）final修饰的类不能被继承 
（2）final修饰的方法不能被重写 
（3）final修饰的属性不能被改变 

## 谈谈final，finally，finalize的区别。 
（1）final用于声明属性，方法和类，分别表示属性不可变，方法不可以覆盖，类不可继承。 
（2）finally是异常处理语句结构的一部分，表示总是执行。 
（3）finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 
 
## Set里的元素是不能重复的，那么用什么方法来区分重复与否，是用==还是equals()?他们有何区别？ 
Set里的元素是不能重复的，用iterator()方法来区分重复与否，equals()是判断两个的Set是否相等。 
equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话放回真值 

## error和exception有什么区别？ 
（1）error表示恢复不是不可能但很困难的情况下的一种严重问题，比如说内存溢出。不可能指望程序能处理这样的情况。 
（2）exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 

## abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？ 
都不可以：  
abstract是抽象的，指的是方法只有声明而没有实现，他的实现要放入声明该类的子类中实现。 
static是静态的，是一种属于类而不属于对象的方法或者属性 

synchronized 是同步，是一种相对线程的锁。 
native 本地方法，这种方法和抽象方法及其类似，它也只有方法声明，没有方法实现，但是它与抽象方法不同的是，它把具体实现移交给了本地系统的函数库，而没有通过虚拟机，可以说是Java与其它语言通讯的一种机制。 

native，这个本身就和abstract冲突，他们都是方法的声明，只是一个把方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢！所以说不能两个一起使用 

## 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？ 
接口可以继承接口，抽象类可以实现接口，抽象类可以继承实现类，但前提是实现类必须有明确的构造函数。 

## try{}里有一个return语句，那么紧跟在这个try后的finally{}里的语句会不会执行，什么时候被执行，在return前还是后？ 
会执行，在return前执行。  

## 面向对象的特征有哪些方面？ 
（1）封装：封装是把对象的属性和实现细节隐藏起来，仅对外提供公共的访问方法（这些对象通过一个受保护的接口访问其他对象）。 

（2）继承：多个类中存在相同的属性和行为时，将这些相同的内容抽取到一个单独的类中，那么多个类无需再定义这些属性和行为，只要继承这个类即可，继承这个类的为新类，新类称为原始类的派生类（子类）而原始类称为新类的基类（父类）。派生类可以从它的基类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。可通过extends关键字实现继承。 

（3）多态：多态性是指允许不同类的对象对同一消息作出响应，多态性语言具有灵活，抽象，行为共享，代码共享的优势，很好解决了应用程序函数同名的问题。 

## int和Integer有什么区别？ 
java提供了两种不同的类型：引用类型和基本类型，int是java的基本类型，integer是java为int提供的包装类。 
## 描述一个JVM加载class文件的原理机制？ 
JVM中类的装载是由ClassLoader和它的子类来实现的，java ClassLoader是一个重要的java运行系统组件，它负责在运行时查找和装入类文件的类。 

## 集合和数组的区别？ 
（1）数组存放基本类型和对象，集合类存放都是对象的引用，而非对象本身。  
（2）数组长度固定无法动态改变，集合类容量动态改变。   
（3）数组无法判断其中实际存有多少元素，length只是告诉了数组的长度是多少，定义了多长的长度后，即使没有存放那么多的元素，没有存放元素的空间就浪费了，而集合的size()可以知道元素的个数。   
（4）集合以类的形式存在，具有封装，继承，多态等类的特征，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率
