# JVM
- 介绍java的数据区域区域
- java对象创建过程
- 对象是如何访问定位的（？？？）
- Java虚拟机类加载机制，双亲委派模型
- String，8钟基本类型和常量池

## JVM数据区域
线程私有：
- 虚拟机栈：
Java方法执行的**内存模型**
单位是栈帧：栈帧（虚拟机进行方法调用和方法执行的数据结构，虚拟机运行时数据区的虚拟机栈）
	- 局部变量
	- 操作数栈
	- 动态链接
	- 方法出口

stackoverflowexeption
outofmemoryerror OOM
- 本地方法栈：其他语言编写处理成相关机器代码，native本地方法

线程共享：
- 堆：
	- 管理所有java实例
	- GC的主要区域
	- OOM
- 方法区
	- 各种class类信息
	- 常量池：基本类型包装类和string
	- 静态变量

**各部分详细解释**
- **线程计数器**：是对应**线程所执行的字节码的行号指示器**。在虚拟机的概念模型里，字节码解释器工作时就是改变这个计数器的值来选取下一条需要执行的字节码指令。
- java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现多线程的执行的。因此在任何一个时刻，一个处理器核（多核处理器的一个核）都只会执行一个线程中的指令。**因此，为了线程切换后，快速定位当前线程上一次执行的位置，就需要通过线程计数器来指定标记。**
- ​**虚拟机栈**：生命周期与线程相同。**虚拟机栈描述的是java方法执行的内存模型**。栈中包含了各种方法运行时所需要的信息。**每个方法在运行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等**。如果线程请求的栈深度超过最大虚拟机的允许深度，会抛出StackOverFlowException。如果方法请求的栈深度无法申请到足够的内存，就会抛出OOM。
- ​**本地方法栈**：与虚拟机栈发挥的作用相似，它们之间的区别不过是**虚拟机栈是为虚拟机执行java字节码服务的；而本地方法栈是为native本地方法来服务的**。
- ​**java堆**：java虚拟机管理的最大一块内存。**堆中管理了所有java对象实例，几乎所有的对象都在这里分配内存**。java堆是GC的主要区域。现代收集器基本采用分代收集算法，所以java堆还可以分为新生代和老年代。进一步的划分是为了更好地回收内存，或者更快地回收内存。**可以通过-Xmx和-Xms命令来设置堆的最大和最小内存**。如果分配时，堆中没有内存可以再进行分配，会抛出OOM。
- ​**方法区**：用于存储已经被jvm加载过后的各种class的类信息、常量、静态变量等数据。
- ​**运行时常量池**（HotSpot中的永久代）：是属于方法区的一部分。class文件除了有类的部分信息以外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。需要注意的是：**程序在运行时，可也将常量放入到常量池中**。当常量池的容量超出限制时，会抛出OOM。

## 对象
### 对象创建
**类加载检查----分配内----初始化零值----设置对象头----执行init方法**

检查常量池中是否有即将要创建的这个对象所属的类的符号引用；
若常量池中没有这个类的符号引用，说明这个类还没有被定义！抛出ClassNotFoundException；
若常量池中有这个类的符号引用，则进行下一步工作；
进而检查这个符号引用所代表的类是否已经被JVM加载；
若该类还没有被加载，就找该类的class文件，并加载进方法区；
若该类已经被JVM加载，则准备为对象分配内存；

### 对象内存模型
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3个区域：对象头（Header）、实例数据(Instance Data)以及对齐补充(padding)。**虚拟机的对象头（MarkWord）包含两部分信息：哈希码(25bit)、GC分代年龄标志(4bit)、锁状态标志(2bit)、线程持有的锁、偏向线程ID、偏向时间戳等**。
- 对象头：类型指针，运行时数据
- 实例数据
- 对齐补充：64bit系统中16bytes

## java虚拟机类加载机制
类的加载：虚拟机把描述类的数据从**Class文件加载到内存**，并对数据进行校验、转换解析的初始化，最终形成可以被虚拟机**直接使用的Java类型**，这就是虚拟机的类加载机制。
对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在java虚拟机中的唯一性。

加载----验证-准备-解析----初始化----使用----卸载
其中验证-准备-解析称为**链接**

- 加载：
	1. 通过一个类的全限定名（？）来获取定义此类的**二进制字节流**
	2. 将这个字节流所代表的静态存储结构（？）转换为方法区的运行时数据结构（？）
	3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
- 验证：
	1. 文件格式验证(是否已魔数开头)
	2. 元数据验证
	3. 字节码验证
- 准备：为类变量分配内存并设置初始化值
- 解析：虚拟机将常量池内的**符号引用**替换为**直接引用**的过程
- 初始化：constructor

### 双亲委派模型 （不懂）
从java虚拟机角度上讲，只存在两种不同的类加载器：一种是**启动类加载器**(Bootstrap ClassLoader),这个类加载器使用C++实现。另一部分是**所有的加载器**，都由java实现，并且全部继承自抽象类ClassLoader。

​	BootstrapClassLoader:负责将存放在JAVA_HOME\lib目录类的库。该类无法被java程序直接引用

​	ExtensionClassLoader:拓展类加载器，加载JAVA_HOME\lib\ext下的库

​	ApplicationClassLoader:系统类加载器加，载Classpath上指定的类库，开发者可以直接使用这个类加载器

类加载器之间的的层次关系：称为双亲委派模型。**双亲委派模型要求：处理底层的启动类加载器以外，其余的类加载器都应有自己的父类加载器**。这里的父子关系不会以继承来实现，而是以组合模式来实现。

​**双亲委派模型流程是：每层的类加载器，都会把类加载的请求转发给父加载器去处理，最后传送到顶层的启动类加载器，只有父加载器无法实现加载时，子加载器才会自己尝试加载。**这样的好处是：无论哪个类要加载一个类，都会最终委派个处于模型最顶端的启动类加载器去加载，**保证了Object类在程序中的各个类加载器环境都是一个类**。

# GC
- GC什么时候触发
- 对象判断可回收算法
- 垃圾收集算法
- 垃圾收集器

## 判断是否回收算法
类需要满足三个条件才能被回收：
1. 该类的所有实例都已被回收
2. 记载该类的ClassLoader已被回收
3.  该类对应的Class对象没有任何地方被引用。无法在任何地方通过反射来访问该类的方法。

**算法：**
- 引用计数：
- 可达性分析：从GC ROOTS的的对象开始查看对应的引用对象，一直遍历下去，如果对象被引用到，则表示该对象不需要进行GC 。若存在对象，使得GC ROOT引用不到，则表示该对象需要被回收

**GC Roots**：
- GC Roots Object作为起点，沿着Reference Chain搜索，未被搜索到的就是不可到达对象
- GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收，可以作为GC Root 引用点的是：
	- Java Stack中的引用的对象。
	- 方法区中静态引用指向的对象。
	- 方法区中常量引用指向的对象。
	- Native方法中JNI引用的对象

## 垃圾收集器算法
- 标记清除（新生代）
- 标记整理（老年代）
- 复制

**标记清除算法（新生代算法）**
分为标记和清除两个过程，标记完成后统一回收所有需要被回收的对象

标记清除的缺点：
1. 产生内存碎片较多，导致内存利用率不高
2. 标记和扫描过程效率不高

**复制算法（新生代算法）**
将堆新生代内存分为两块。一半用于存储对象内存，然后将不需要的内存放入另一半中，最后将这一半内存全部清空，使得每次只对一个半区进行回收。现代商业算法都是采用此方案，不过不是划分一半，而是分为Eden和survivor区，一般而言Eden和Survivor的比例是8:1。

复制算法优点：

1. 算法简单，比较容易实现
2. 不会产生内存碎片
3. 内存都是连续分配的       

复制算法缺点：

1. 内存空间利用率较小，每次只有一半空间能使用
2. 将不需要gc的对象复制到令一半区，性能耗费较大

**标记-整理算法(老年代算法)**
标记过程与标记-清除一样，只是标记之后不再清除。而是将剩余的存活对象内存相互整理，清除内存碎片，提高内存空间利用率。


## 垃圾收集器
标记清除（整理）
- serial，serial old（单线程）
- parnew （多线程）
- CMS （多线程）
复制
- Parallel，Parallel old（多线程）
- scavenge 

### Serial回收器(新生代回收器)
单线程回收器。是指它在工作时，必须暂停所有工作进程，直到它收集结束(Stop the World)。
Serial收集器新生代采用标记-清除算法。老年代采用标记-整理算法。

### Parnew收集器(新生代)
Serial收集器的多线程版本，除了使用多线程进行垃圾回收之外，其余行为与Serial一致，包括Stop the World。新生代采用标记-清除算法，老年代采用标记-整理算法。Parnew是许多运行在Server模式下虚拟机的首选。

不懂多线程了为为什么还stop the world
**Serial和Parnew都能与CMS进行配合**。

### Parallel Scavenge(新生代收集器)
**采用复制算法实现的新生代收集器，而且是并行的的多线程收集器**。
其目的是达到一个可控制的吞吐量。停顿时间越短则越适合执行与用户进行交互的程序。

### Serial Old（老年代收集器）
以标记-整理作为实现原理，同样是一个单线程收集器，需要Stop the World。

### Parallel Old(老年代收集器)
Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。同样注重吞吐量优先。

### CMS收集器(老年代收集器)

Concurrent Mark Sweep。采用**标记-整理**算法，它是以获取**最短停顿时间**为目标的收集器。
CMS的执行过程如下：

1. 初始标记（Stop the world）：标记GC Root能够直接关联的对象，速度很快
2. 并发标记： GC ROOT tracing。时间较长
3. 重新标记（Stop the World）：为了修正并发期间因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。停顿时间比初始标记稍长
4. 并发清除：时间较长

由于整个过程耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。所以，从总体上讲，CMS收集器的回收过程是与用户进程一起并发执行的。

### G1收集器
面向服务端应用的垃圾回收器。
G1收集器的运作步骤大致如下：

1. 初始标记
2. 并发标记
3. 最终标记：为了修正在并发标记期间因用户程序据需运作而导致标记产生变动的那一部分标记记录。
4. 筛选标记

G1的优点如下：

1. 并行与并发
2. 分代收集
3. 空间整合
4. 可预测的停顿


## 回收的时机
- scavenge GC：Eden区申请空间失败
- Full GC：老年区写满或手动触发

### 大对象直接进入老年代
所谓的大对象是指，需要大量的连续内存空间的java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息。可以将比较大的对象之间存储到老年代中，以避免新生代Eden和Survivor之间的大对象复制带来的性能消耗。

### 长期存活的对象进入老年代
虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过一次Minor GC之后仍然存活，并且能够被Survivor容纳的话，就会被移动到Survivor空间中，并且对象年龄设为1。当对象的年龄增加到一定程度之后，就会直接晋升到老年代。

## 内存泄漏与内存溢出
### **内存泄漏：分配出去的内存却无法回收**

参考： [https://blog.csdn.net/anxpp/article/details/51325838](https://blog.csdn.net/anxpp/article/details/51325838)

- Java尽管有GC，仍然会内存泄露(OOM error: out of heap space)
- GC中不会被使用对象的就会被回收
- 不会再被使用的对象不能被回收，即内存泄露

常见： 如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露
例如：

- 在只需要局部变量就够的时候使用实例变量，该变量其实被使用完了却只会在类的所有对象被释放时才会释放
- 当一个collection内元素全部为null的时候，collection应当被回收却回收不掉

### **内存溢出：程序要求的内存超出了所能分配的最大内存**
补充
