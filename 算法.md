# 算法
## 贪心
贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

**它需要证明后才能真正运用到题目的算法中。**  
构造贪心策略很简单，但是不一定是**最优解**  

应用：  
背包问题  
马踏棋盘  
Kruskal算法（最小生成树）  
Dijkstra  

## 动态规划
动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，**前一子问题的解，为后一子问题的求解提供了有用的信息**。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

最优解的子解集也是最优的-》递归   

应用：  
背包问题
最大子数组和

## QuickSort, MergeSort, HeapSort

快速排序（Quick Sort）和归并排序（Merge Sort）是算法面试必修的两个基础知识点。很多的算法面试题，要么是直接问这两个算法，要么是这两个算法的变化，要么是用到了这两个算法中同样的思想或者实现方式，要么是挑出这两个算法中的某个步骤来考察。
本小节将从算法原理，实现，以及时间复杂度，空间复杂度、排序稳定性等方面的对比，让大家对这两个经典算法有一个更深入的理解和认识。
###快速排序算法 Quick Sort
- 选择pivot，进行partition，分成两个部分；先整体有序，后局部有序
- 等号问题 使用<= >=，为了避免一样的数的影响
- pivot选择尽量左右差不多

eg

	quickSort(A, 0, A.length-1);
	private void quickSort(int[]A, int start, int end){ 
	    if(start>=end){ 
	        return ; 
	    } 
	    int left = start, right = end; int pivot = ...; 
	// pivot 的选区不能是首尾，要用value，不能用index int pivot = A[(start+end)/2]; // or use random
	// left<=right not left<right,避免left，right有交集
	// 否则会出现stack overflow，比如[1,2]
	while (left <= right){
	    while (left<=right && A[left] < pivot){
	        // A[left] < pivot 避免出现不均匀的情况
	        // 比如全部为1
	        left++;
	    }
	    while(right...){
	        right--;
	    }
	    if(left<=right){
	        swap(A[left], A[right]);
	        left++;
	        right--;
	    }
	}
	// recursion
	quickSort(A, start, right);
	quickSort(A, left, end);
	}


### 归并排序 Merge Sort
* O(N) 额外空间，此为相比quickSort的劣势
* 重点是分治的思想，和merge的写法

eg

	public class Solution {
	    /**
	     * @param A: an integer array
	     * @return: nothing
	     */
	    public void sortIntegers(int[] A) {
	        if(A == null || A.length == 0){
	            return;
	        }
	        int start = 0;
	        int end = A.length-1;
	        // why I put temp here is to avoid create a new array in mergeSort each time
	        // temp stores result
	        int[] temp = new int[A.length];
	        mergeSort(A, start, end, temp);
	    }
	    
	    private void mergeSort(int[] A, int start, int end, int[] temp){
	        if (start >= end) {
	            return;
	        }
	        mergeSort(A, start, (start+end)/2, temp);
	        mergeSort(A, (start+end)/2+1, end, temp);
	        // key point, how to merge
	        merge(A, start, end, temp);
	    }
	    
	    private void merge(int[] A, int start, int end, int[] temp){
	        // mid is the end of left part
	        int mid = (start + end)/2;
	        // leftIndex track the index of the left part
	        int leftIndex = start;
	        int rightIndex = mid+1;
	        int index = start;
	        
	        while (leftIndex <= mid && rightIndex <= end){
	            if(A[leftIndex] < A[rightIndex]){
	                temp[index++] = A[leftIndex++];
	            } else {
	                temp[index++] = A[rightIndex++];
	            }
	        }
	        // in case where left part or the right part are not completed
	        while (leftIndex<=mid){
	            temp[index++] = A[leftIndex++];
	        }
	        while (rightIndex<=end){
	            temp[index++] = A[rightIndex++];
	        }
	        // copy temp back to A
	        for (index = start; index <= end; index++) {
	            A[index] = temp[index];
	        }
	    }
	}

### 堆排序HeapSort
- 利用**大根堆**数据结构
- 每次都取堆顶的元素，将其放在序列最后面，然后将剩余的元素重新调整为最大堆
- 时间O(nlgn）
- 因为堆排序是就地排序，空间复杂度为常数：O(1)
